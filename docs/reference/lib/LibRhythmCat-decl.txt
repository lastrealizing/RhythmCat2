<MACRO>
<NAME>G_LOG_DOMAIN</NAME>
#define G_LOG_DOMAIN "LibRhythmCat2"
</MACRO>
<MACRO>
<NAME>GETTEXT_PACKAGE</NAME>
#define GETTEXT_PACKAGE "LibRhythmCat2"
</MACRO>
<MACRO>
<NAME>PACKAGE</NAME>
#define PACKAGE "LibRhythmCat2"
</MACRO>
<MACRO>
<NAME>RCLIB_CORE_TYPE</NAME>
#define RCLIB_CORE_TYPE (rclib_core_get_type())
</MACRO>
<MACRO>
<NAME>RCLIB_CORE</NAME>
#define RCLIB_CORE(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), RCLIB_CORE_TYPE, \
    RCLibCore))
</MACRO>
<MACRO>
<NAME>RCLIB_CORE_CLASS</NAME>
#define RCLIB_CORE_CLASS(k) (G_TYPE_CHECK_CLASS_CAST((k), RCLIB_CORE_TYPE, \
    RCLibCoreClass))
</MACRO>
<MACRO>
<NAME>RCLIB_IS_CORE</NAME>
#define RCLIB_IS_CORE(o) (G_TYPE_CHECK_INSTANCE_TYPE((o), RCLIB_CORE_TYPE))
</MACRO>
<MACRO>
<NAME>RCLIB_IS_CORE_CLASS</NAME>
#define RCLIB_IS_CORE_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE((k), RCLIB_CORE_TYPE))
</MACRO>
<MACRO>
<NAME>RCLIB_CORE_GET_CLASS</NAME>
#define RCLIB_CORE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), \
    RCLIB_CORE_TYPE, RCLibCoreClass))
</MACRO>
<ENUM>
<NAME>RCLibCoreSourceType</NAME>
typedef enum {
    RCLIB_CORE_SOURCE_NONE = 0,
    RCLIB_CORE_SOURCE_NORMAL = 1,
    RCLIB_CORE_SOURCE_CUE = 2,
    RCLIB_CORE_SOURCE_EMBEDED_CUE = 3
}RCLibCoreSourceType;
</ENUM>
<ENUM>
<NAME>RCLibCoreErrorCode</NAME>
typedef enum {
    RCLIB_CORE_ERROR_OK = 0,
    RCLIB_CORE_ERROR_ALREADY_INIT = 1,
    RCLIB_CORE_ERROR_NOT_INIT = 2,
    RCLIB_CORE_ERROR_MISSING_CORE_PLUGIN = 3,
    RCLIB_CORE_ERROR_CREATE_BIN_FAILED = 4,
    RCLIB_CORE_ERROR_LINK_FAILED = 5
}RCLibCoreErrorCode;
</ENUM>
<ENUM>
<NAME>RCLibCoreEQType</NAME>
typedef enum {
    RCLIB_CORE_EQ_TYPE_NONE = 0,
    RCLIB_CORE_EQ_TYPE_POP = 1,
    RCLIB_CORE_EQ_TYPE_ROCK = 2,
    RCLIB_CORE_EQ_TYPE_METAL = 3,
    RCLIB_CORE_EQ_TYPE_DANCE = 4,
    RCLIB_CORE_EQ_TYPE_ELECTRONIC = 5,
    RCLIB_CORE_EQ_TYPE_JAZZ = 6,
    RCLIB_CORE_EQ_TYPE_CLASSICAL = 7,
    RCLIB_CORE_EQ_TYPE_BLUES = 8,
    RCLIB_CORE_EQ_TYPE_VOCAL = 9,
    RCLIB_CORE_EQ_TYPE_CUSTOM = 10
}RCLibCoreEQType;
</ENUM>
<STRUCT>
<NAME>RCLibCoreMetadata</NAME>
struct _RCLibCoreMetadata {
    gchar *title;
    gchar *artist;
    gchar *album;
    gchar *ftype;
    guint bitrate;
    gint64 duration;
    gint track;
    gint year;
    gint rate;
    gint channels;
    GstBuffer *image;
};
</STRUCT>
<STRUCT>
<NAME>RCLibCore</NAME>
struct _RCLibCore {
    /*< private >*/
    GObject parent;
};
</STRUCT>
<STRUCT>
<NAME>RCLibCoreClass</NAME>
struct _RCLibCoreClass {
    /*< private >*/
    GObjectClass parent_class;
    void (*state_changed)(RCLibCore *core, GstState state);
    void (*eos)(RCLibCore *core);
    void (*tag_found)(RCLibCore *core, const RCLibCoreMetadata *metadata,
        const gchar *uri);
    void (*new_duration)(RCLibCore *core, gint64 duration);
    void (*uri_changed)(RCLibCore *core, const gchar *uri);
    void (*volume_changed)(RCLibCore *core, gdouble volume);
    void (*eq_changed)(RCLibCore *core, RCLibCoreEQType type,
        gdouble *values);
    void (*balance_changed)(RCLibCore *core, gfloat balance);
    void (*echo_changed)(RCLibCore *core);
    void (*spectrum_updated)(RCLibCore *core, guint rate, guint bands,
        const GValue *magnitudes);
    void (*error)(RCLibCore *core);
};
</STRUCT>
<FUNCTION>
<NAME>rclib_core_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_init</NAME>
<RETURNS>gboolean  </RETURNS>
GError **error 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_exit</NAME>
<RETURNS>void  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_get_instance</NAME>
<RETURNS>GObject  *</RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_signal_connect</NAME>
<RETURNS>gulong  </RETURNS>
const gchar *name, GCallback callback, gpointer data 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_signal_disconnect</NAME>
<RETURNS>void  </RETURNS>
gulong handler_id 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_set_uri</NAME>
<RETURNS>void  </RETURNS>
const gchar *uri, GSequenceIter *db_reference, gpointer external_reference 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_update_db_reference</NAME>
<RETURNS>void  </RETURNS>
GSequenceIter *new_ref 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_update_external_reference</NAME>
<RETURNS>void  </RETURNS>
gpointer new_ref 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_get_uri</NAME>
<RETURNS>gchar  *</RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_get_db_reference</NAME>
<RETURNS>GSequenceIter  *</RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_get_external_reference</NAME>
<RETURNS>gpointer  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_get_source_type</NAME>
<RETURNS>RCLibCoreSourceType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_get_metadata</NAME>
<RETURNS>const RCLibCoreMetadata  *</RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_set_position</NAME>
<RETURNS>gboolean  </RETURNS>
gint64 pos 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_query_position</NAME>
<RETURNS>gint64  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_query_duration</NAME>
<RETURNS>gint64  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_get_state</NAME>
<RETURNS>GstStateChangeReturn  </RETURNS>
GstState *state, GstState *pending, GstClockTime timeout 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_play</NAME>
<RETURNS>gboolean  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_pause</NAME>
<RETURNS>gboolean  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_stop</NAME>
<RETURNS>gboolean  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_set_volume</NAME>
<RETURNS>gboolean  </RETURNS>
gdouble volume 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_get_volume</NAME>
<RETURNS>gboolean  </RETURNS>
gdouble *volume 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_set_eq</NAME>
<RETURNS>gboolean  </RETURNS>
RCLibCoreEQType type, gdouble *band 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_get_eq</NAME>
<RETURNS>gboolean  </RETURNS>
RCLibCoreEQType *type, gdouble *band 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_get_eq_name</NAME>
<RETURNS>const gchar  *</RETURNS>
RCLibCoreEQType type 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_set_balance</NAME>
<RETURNS>gboolean  </RETURNS>
gfloat balance 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_get_balance</NAME>
<RETURNS>gboolean  </RETURNS>
gfloat *balance 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_set_echo</NAME>
<RETURNS>gboolean  </RETURNS>
guint64 delay, gfloat feedback, gfloat intensity 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_get_echo</NAME>
<RETURNS>gboolean  </RETURNS>
guint64 *delay, guint64 *max_delay, gfloat *feedback, gfloat *intensity 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_effect_plugin_add</NAME>
<RETURNS>gboolean  </RETURNS>
GstElement *element 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_effect_plugin_remove</NAME>
<RETURNS>void  </RETURNS>
GstElement *element 
</FUNCTION>
<FUNCTION>
<NAME>rclib_core_effect_plugin_get_list</NAME>
<RETURNS>GList  *</RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>RCLIB_ALBUM_TYPE</NAME>
#define RCLIB_ALBUM_TYPE (rclib_album_get_type())
</MACRO>
<MACRO>
<NAME>RCLIB_ALBUM</NAME>
#define RCLIB_ALBUM(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), \
    RCLIB_ALBUM_TYPE, RCLibAlbum))
</MACRO>
<MACRO>
<NAME>RCLIB_ALBUM_CLASS</NAME>
#define RCLIB_ALBUM_CLASS(k) (G_TYPE_CHECK_CLASS_CAST((k), \
    RCLIB_ALBUM_TYPE, RCLibAlbumClass))
</MACRO>
<MACRO>
<NAME>RCLIB_IS_ALBUM</NAME>
#define RCLIB_IS_ALBUM(o) (G_TYPE_CHECK_INSTANCE_TYPE((o), \
    RCLIB_ALBUM_TYPE))
</MACRO>
<MACRO>
<NAME>RCLIB_IS_ALBUM_CLASS</NAME>
#define RCLIB_IS_ALBUM_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE((k), \
    RCLIB_ALBUM_TYPE))
</MACRO>
<MACRO>
<NAME>RCLIB_ALBUM_GET_CLASS</NAME>
#define RCLIB_ALBUM_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), \
    RCLIB_ALBUM_TYPE, RCLibAlbumClass))
</MACRO>
<ENUM>
<NAME>RCLibAlbumType</NAME>
typedef enum {
    RCLIB_ALBUM_TYPE_FILENAME,
    RCLIB_ALBUM_TYPE_BUFFER
}RCLibAlbumType;
</ENUM>
<STRUCT>
<NAME>RCLibAlbum</NAME>
struct _RCLibAlbum {
    /*< private >*/
    GObject parent;
};
</STRUCT>
<STRUCT>
<NAME>RCLibAlbumClass</NAME>
struct _RCLibAlbumClass {
    /*< private >*/
    GObjectClass parent_class;
    void (*album_found)(RCLibAlbum *album, guint type, gpointer album_data);
    void (*album_none)(RCLibAlbum *album);
};
</STRUCT>
<FUNCTION>
<NAME>rclib_album_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_album_init</NAME>
<RETURNS>void  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_album_exit</NAME>
<RETURNS>void  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_album_get_instance</NAME>
<RETURNS>GObject  *</RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_album_signal_connect</NAME>
<RETURNS>gulong  </RETURNS>
const gchar *name, GCallback callback, gpointer data 
</FUNCTION>
<FUNCTION>
<NAME>rclib_album_signal_disconnect</NAME>
<RETURNS>void  </RETURNS>
gulong handler_id 
</FUNCTION>
<FUNCTION>
<NAME>rclib_album_get_album_data</NAME>
<RETURNS>gboolean  </RETURNS>
RCLibAlbumType *type, gpointer *data 
</FUNCTION>
<FUNCTION>
<NAME>rclib_album_save_file</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *filename 
</FUNCTION>
<MACRO>
<NAME>RCLIB_LYRIC_TYPE</NAME>
#define RCLIB_LYRIC_TYPE (rclib_lyric_get_type())
</MACRO>
<MACRO>
<NAME>RCLIB_LYRIC</NAME>
#define RCLIB_LYRIC(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), \
    RCLIB_LYRIC_TYPE, RCLibLyric))
</MACRO>
<MACRO>
<NAME>RCLIB_LYRIC_CLASS</NAME>
#define RCLIB_LYRIC_CLASS(k) (G_TYPE_CHECK_CLASS_CAST((k), \
    RCLIB_LYRIC_TYPE, RCLibLyricClass))
</MACRO>
<MACRO>
<NAME>RCLIB_IS_LYRIC</NAME>
#define RCLIB_IS_LYRIC(o) (G_TYPE_CHECK_INSTANCE_TYPE((o), \
    RCLIB_LYRIC_TYPE))
</MACRO>
<MACRO>
<NAME>RCLIB_IS_LYRIC_CLASS</NAME>
#define RCLIB_IS_LYRIC_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE((k), \
    RCLIB_LYRIC_TYPE))
</MACRO>
<MACRO>
<NAME>RCLIB_LYRIC_GET_CLASS</NAME>
#define RCLIB_LYRIC_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), \
    RCLIB_LYRIC_TYPE, RCLibLyricClass))
</MACRO>
<STRUCT>
<NAME>RCLibLyricData</NAME>
struct _RCLibLyricData {
    gint64 time;
    gint64 length;
    gchar *text;
};
</STRUCT>
<STRUCT>
<NAME>RCLibLyric</NAME>
struct _RCLibLyric {
    /*< private >*/
    GObject parent;
};
</STRUCT>
<STRUCT>
<NAME>RCLibLyricClass</NAME>
struct _RCLibLyricClass {
    /*< private >*/
    GObjectClass parent_class;
    void (*lyric_ready)(RCLibLyric *lyric, guint index);
    void (*line_changed)(RCLibLyric *lyric, guint index,
        const RCLibLyricData *lyric_data);
    void (*lyric_timer)(RCLibLyric *lyric, guint index,
        gint64 pos, const RCLibLyricData *lyric_data);
};
</STRUCT>
<FUNCTION>
<NAME>rclib_lyric_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_lyric_init</NAME>
<RETURNS>void  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_lyric_exit</NAME>
<RETURNS>void  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_lyric_get_instance</NAME>
<RETURNS>GObject  *</RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_lyric_signal_connect</NAME>
<RETURNS>gulong  </RETURNS>
const gchar *name, GCallback callback, gpointer data 
</FUNCTION>
<FUNCTION>
<NAME>rclib_lyric_signal_disconnect</NAME>
<RETURNS>void  </RETURNS>
gulong handler_id 
</FUNCTION>
<FUNCTION>
<NAME>rclib_lyric_set_fallback_encoding</NAME>
<RETURNS>void  </RETURNS>
const gchar *encoding 
</FUNCTION>
<FUNCTION>
<NAME>rclib_lyric_get_fallback_encoding</NAME>
<RETURNS>const gchar  *</RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_lyric_load_file</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *filename, guint index 
</FUNCTION>
<FUNCTION>
<NAME>rclib_lyric_clean</NAME>
<RETURNS>void  </RETURNS>
guint index 
</FUNCTION>
<FUNCTION>
<NAME>rclib_lyric_get_line</NAME>
<RETURNS>const RCLibLyricData  *</RETURNS>
guint index, gint64 time 
</FUNCTION>
<FUNCTION>
<NAME>rclib_lyric_set_search_dir</NAME>
<RETURNS>void  </RETURNS>
const gchar *dir 
</FUNCTION>
<FUNCTION>
<NAME>rclib_lyric_get_search_dir</NAME>
<RETURNS>const gchar  *</RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_lyric_search_lyric</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *uri, const gchar *title, const gchar *artist 
</FUNCTION>
<FUNCTION>
<NAME>rclib_lyric_is_available</NAME>
<RETURNS>gboolean  </RETURNS>
guint index 
</FUNCTION>
<STRUCT>
<NAME>RCLibTagMetadata</NAME>
struct _RCLibTagMetadata {
    gint64 length;
    gchar *uri;
    guint tracknum;
    guint bitrate;
    gint samplerate;
    gint channels;
    gint year;
    gchar *title;
    gchar *artist;
    gchar *album;
    gchar *comment;
    gchar *ftype;
    gchar *emb_cue;
    GstBuffer *image;
    gboolean eos;
    gboolean audio_flag;
    gboolean video_flag;
    gpointer user_data;
};
</STRUCT>
<FUNCTION>
<NAME>rclib_tag_read_metadata</NAME>
<RETURNS>RCLibTagMetadata  *</RETURNS>
const gchar *uri 
</FUNCTION>
<FUNCTION>
<NAME>rclib_tag_free</NAME>
<RETURNS>void  </RETURNS>
RCLibTagMetadata *mmd 
</FUNCTION>
<FUNCTION>
<NAME>rclib_tag_get_name_from_fpath</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *filename 
</FUNCTION>
<FUNCTION>
<NAME>rclib_tag_set_fallback_encoding</NAME>
<RETURNS>void  </RETURNS>
const gchar *encoding 
</FUNCTION>
<FUNCTION>
<NAME>rclib_tag_get_fallback_encoding</NAME>
<RETURNS>const gchar  *</RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>RCLIB_PLUGIN_MAGIC</NAME>
#define RCLIB_PLUGIN_MAGIC 0x20120103
</MACRO>
<MACRO>
<NAME>RCLIB_PLUGIN_MAJOR_VERSION</NAME>
#define RCLIB_PLUGIN_MAJOR_VERSION 2
</MACRO>
<MACRO>
<NAME>RCLIB_PLUGIN_MINOR_VERSION</NAME>
#define RCLIB_PLUGIN_MINOR_VERSION 0
</MACRO>
<MACRO>
<NAME>RCLIB_PLUGIN_TYPE</NAME>
#define RCLIB_PLUGIN_TYPE (rclib_plugin_get_type())
</MACRO>
<MACRO>
<NAME>RCLIB_PLUGIN</NAME>
#define RCLIB_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), \
    RCLIB_PLUGIN_TYPE, RCLibPlugin))
</MACRO>
<MACRO>
<NAME>RCLIB_PLUGIN_CLASS</NAME>
#define RCLIB_PLUGIN_CLASS(k) (G_TYPE_CHECK_CLASS_CAST((k), \
    RCLIB_PLUGIN_TYPE, RCLibPluginClass))
</MACRO>
<MACRO>
<NAME>RCLIB_IS_PLUGIN</NAME>
#define RCLIB_IS_PLUGIN(o) (G_TYPE_CHECK_INSTANCE_TYPE((o), \
    RCLIB_PLUGIN_TYPE))
</MACRO>
<MACRO>
<NAME>RCLIB_IS_PLUGIN_CLASS</NAME>
#define RCLIB_IS_PLUGIN_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE((k), \
    RCLIB_PLUGIN_TYPE))
</MACRO>
<MACRO>
<NAME>RCLIB_PLUGIN_GET_CLASS</NAME>
#define RCLIB_PLUGIN_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), \
    RCLIB_PLUGIN_TYPE, RCLibPluginClass))
</MACRO>
<MACRO>
<NAME>RCPLUGIN_INIT_PLUGIN</NAME>
#define RCPLUGIN_INIT_PLUGIN(pluginname, initfunc, plugininfo) \
    G_MODULE_EXPORT gboolean rcplugin_init(RCLibPluginData *plugin) \
    { \
        plugin->info = &(plugininfo); \
        return initfunc((plugin)); \
    }
</MACRO>
<ENUM>
<NAME>RCLibPluginType</NAME>
typedef enum {
    RCLIB_PLUGIN_TYPE_UNKNOWN = 0,
    RCLIB_PLUGIN_TYPE_MODULE = 1,
    RCLIB_PLUGIN_TYPE_LOADER = 2
}RCLibPluginType;
</ENUM>
<STRUCT>
<NAME>RCLibPluginInfo</NAME>
struct _RCLibPluginInfo {
    guint32 magic;
    guint32 major_version;
    guint32 minor_version;
    RCLibPluginType type;
    gchar *id;
    gchar *name;
    gchar *version;
    gchar *description;
    gchar *author;
    gchar *homepage;
    gboolean (*load)(RCLibPluginData *plugin);
    gboolean (*unload)(RCLibPluginData *plugin);
    void (*destroy)(RCLibPluginData *plugin);
    gboolean (*configure)(RCLibPluginData *plugin);
    gchar **depends;
    gpointer extra_info;
};
</STRUCT>
<STRUCT>
<NAME>RCLibPluginLoaderInfo</NAME>
struct _RCLibPluginLoaderInfo {
    const gchar * const *extensions;
    gboolean (*probe)(RCLibPluginData *plugin);
    gboolean (*load)(RCLibPluginData *plugin);
    gboolean (*unload)(RCLibPluginData *plugin);
    void (*destroy)(RCLibPluginData *plugin);
};
</STRUCT>
<STRUCT>
<NAME>RCLibPluginData</NAME>
struct _RCLibPluginData {
    /*< private >*/
    gint ref_count;
    
    /*< public >*/
    gboolean native;
    gboolean loaded;
    gpointer handle;
    gchar *path;
    RCLibPluginInfo *info;
    gchar *error;
    gboolean unloadable;
    GSList *dependent_list;
    gpointer extra;
    gpointer ipc_data;

    /*< private >*/
    void (*_rclib_plugin_reserved1)(void);
    void (*_rclib_plugin_reserved2)(void);
    void (*_rclib_plugin_reserved3)(void);
    void (*_rclib_plugin_reserved4)(void);
};
</STRUCT>
<STRUCT>
<NAME>RCLibPlugin</NAME>
struct _RCLibPlugin {
    /*< private >*/
    GObject parent;
};
</STRUCT>
<STRUCT>
<NAME>RCLibPluginClass</NAME>
struct _RCLibPluginClass {
    /*< private >*/
    GObjectClass parent_class;
    void (*registered)(RCLibPlugin *plugin, const RCLibPluginData *data);
    void (*loaded)(RCLibPlugin *plugin, const RCLibPluginData *data);
    void (*unloaded)(RCLibPlugin *plugin, const RCLibPluginData *data);
    void (*unregistered)(RCLibPlugin *plugin, const gchar *id);
};
</STRUCT>
<FUNCTION>
<NAME>rclib_plugin_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *file 
</FUNCTION>
<FUNCTION>
<NAME>rclib_plugin_exit</NAME>
<RETURNS>void  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_plugin_get_instance</NAME>
<RETURNS>GObject  *</RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_plugin_signal_connect</NAME>
<RETURNS>gulong  </RETURNS>
const gchar *name, GCallback callback, gpointer data 
</FUNCTION>
<FUNCTION>
<NAME>rclib_plugin_signal_disconnect</NAME>
<RETURNS>void  </RETURNS>
gulong handler_id 
</FUNCTION>
<FUNCTION>
<NAME>rclib_plugin_probe</NAME>
<RETURNS>RCLibPluginData  *</RETURNS>
const gchar *filename 
</FUNCTION>
<FUNCTION>
<NAME>rclib_plugin_register</NAME>
<RETURNS>gboolean  </RETURNS>
RCLibPluginData *plugin 
</FUNCTION>
<FUNCTION>
<NAME>rclib_plugin_data_ref</NAME>
<RETURNS>RCLibPluginData  *</RETURNS>
RCLibPluginData *plugin 
</FUNCTION>
<FUNCTION>
<NAME>rclib_plugin_data_unref</NAME>
<RETURNS>void  </RETURNS>
RCLibPluginData *plugin 
</FUNCTION>
<FUNCTION>
<NAME>rclib_plugin_load_from_dir</NAME>
<RETURNS>guint  </RETURNS>
const gchar *dirname 
</FUNCTION>
<FUNCTION>
<NAME>rclib_plugin_load</NAME>
<RETURNS>gboolean  </RETURNS>
RCLibPluginData *plugin 
</FUNCTION>
<FUNCTION>
<NAME>rclib_plugin_unload</NAME>
<RETURNS>gboolean  </RETURNS>
RCLibPluginData *plugin 
</FUNCTION>
<FUNCTION>
<NAME>rclib_plugin_reload</NAME>
<RETURNS>gboolean  </RETURNS>
RCLibPluginData *plugin 
</FUNCTION>
<FUNCTION>
<NAME>rclib_plugin_is_loaded</NAME>
<RETURNS>gboolean  </RETURNS>
RCLibPluginData *plugin 
</FUNCTION>
<FUNCTION>
<NAME>rclib_plugin_destroy</NAME>
<RETURNS>void  </RETURNS>
RCLibPluginData *plugin 
</FUNCTION>
<FUNCTION>
<NAME>rclib_plugin_foreach</NAME>
<RETURNS>void  </RETURNS>
GHFunc func, gpointer data 
</FUNCTION>
<FUNCTION>
<NAME>rclib_plugin_lookup</NAME>
<RETURNS>RCLibPluginData  *</RETURNS>
const gchar *id 
</FUNCTION>
<FUNCTION>
<NAME>rclib_plugin_destroy_all</NAME>
<RETURNS>void  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_plugin_load_from_configure</NAME>
<RETURNS>void  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_plugin_get_keyfile</NAME>
<RETURNS>GKeyFile  *</RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>RCLIB_PLAYER_TYPE</NAME>
#define RCLIB_PLAYER_TYPE (rclib_player_get_type())
</MACRO>
<MACRO>
<NAME>RCLIB_PLAYER</NAME>
#define RCLIB_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), \
    RCLIB_PLAYER_TYPE, RCLibPlayer))
</MACRO>
<MACRO>
<NAME>RCLIB_PLAYER_CLASS</NAME>
#define RCLIB_PLAYER_CLASS(k) (G_TYPE_CHECK_CLASS_CAST((k), \
    RCLIB_PLAYER_TYPE, RCLibPlayerClass))
</MACRO>
<MACRO>
<NAME>RCLIB_IS_PLAYER</NAME>
#define RCLIB_IS_PLAYER(o) (G_TYPE_CHECK_INSTANCE_TYPE((o), \
    RCLIB_PLAYER_TYPE))
</MACRO>
<MACRO>
<NAME>RCLIB_IS_PLAYER_CLASS</NAME>
#define RCLIB_IS_PLAYER_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE((k), \
    RCLIB_PLAYER_TYPE))
</MACRO>
<MACRO>
<NAME>RCLIB_PLAYER_GET_CLASS</NAME>
#define RCLIB_PLAYER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), \
    RCLIB_PLAYER_TYPE, RCLibPlayerClass))
</MACRO>
<ENUM>
<NAME>RCLibPlayerRepeatMode</NAME>
typedef enum {
    RCLIB_PLAYER_REPEAT_NONE,
    RCLIB_PLAYER_REPEAT_SINGLE,
    RCLIB_PLAYER_REPEAT_LIST,
    RCLIB_PLAYER_REPEAT_ALL
}RCLibPlayerRepeatMode;
</ENUM>
<ENUM>
<NAME>RCLibPlayerRandomMode</NAME>
typedef enum {
    RCLIB_PLAYER_RANDOM_NONE,
    RCLIB_PLAYER_RANDOM_SINGLE,
    RCLIB_PlAYER_RANDOM_ALL
}RCLibPlayerRandomMode;
</ENUM>
<STRUCT>
<NAME>RCLibPlayer</NAME>
struct _RCLibPlayer {
    /*< private >*/
    GObject parent;
};
</STRUCT>
<STRUCT>
<NAME>RCLibPlayerClass</NAME>
struct _RCLibPlayerClass {
    /*< private >*/
    GObjectClass parent_class;
    void (*repeat_mode_changed)(RCLibPlayer *player,
        RCLibPlayerRepeatMode mode);
    void (*random_mode_changed)(RCLibPlayer *player,
        RCLibPlayerRandomMode mode);
};
</STRUCT>
<FUNCTION>
<NAME>rclib_player_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_player_init</NAME>
<RETURNS>void  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_player_exit</NAME>
<RETURNS>void  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_player_get_instance</NAME>
<RETURNS>GObject  *</RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_player_signal_connect</NAME>
<RETURNS>gulong  </RETURNS>
const gchar *name, GCallback callback, gpointer data 
</FUNCTION>
<FUNCTION>
<NAME>rclib_player_signal_disconnect</NAME>
<RETURNS>void  </RETURNS>
gulong handler_id 
</FUNCTION>
<FUNCTION>
<NAME>rclib_player_play_db</NAME>
<RETURNS>void  </RETURNS>
GSequenceIter *iter 
</FUNCTION>
<FUNCTION>
<NAME>rclib_player_play_uri</NAME>
<RETURNS>void  </RETURNS>
const gchar *uri 
</FUNCTION>
<FUNCTION>
<NAME>rclib_player_play_prev</NAME>
<RETURNS>void  </RETURNS>
gboolean jump, gboolean repeat, gboolean loop 
</FUNCTION>
<FUNCTION>
<NAME>rclib_player_play_next</NAME>
<RETURNS>void  </RETURNS>
gboolean jump, gboolean repeat, gboolean loop 
</FUNCTION>
<FUNCTION>
<NAME>rclib_player_set_repeat_mode</NAME>
<RETURNS>void  </RETURNS>
RCLibPlayerRepeatMode mode 
</FUNCTION>
<FUNCTION>
<NAME>rclib_player_set_random_mode</NAME>
<RETURNS>void  </RETURNS>
RCLibPlayerRandomMode mode 
</FUNCTION>
<FUNCTION>
<NAME>rclib_player_get_repeat_mode</NAME>
<RETURNS>RCLibPlayerRepeatMode  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_player_get_random_mode</NAME>
<RETURNS>RCLibPlayerRandomMode  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_settings_init</NAME>
<RETURNS>gboolean  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_settings_exit</NAME>
<RETURNS>void  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_settings_load_from_file</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *filename 
</FUNCTION>
<FUNCTION>
<NAME>rclib_settings_apply</NAME>
<RETURNS>void  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_settings_update</NAME>
<RETURNS>void  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_settings_sync</NAME>
<RETURNS>void  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_settings_get_string</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *group_name, const gchar *key, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>rclib_settings_get_integer</NAME>
<RETURNS>gint  </RETURNS>
const gchar *group_name, const gchar *key, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>rclib_settings_get_double</NAME>
<RETURNS>gdouble  </RETURNS>
const gchar *group_name, const gchar *key, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>rclib_settings_get_boolean</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *group_name, const gchar *key, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>rclib_settings_get_string_list</NAME>
<RETURNS>gchar  **</RETURNS>
const gchar *group_name, const gchar *key, gsize *length, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>rclib_settings_get_boolean_list</NAME>
<RETURNS>gboolean  *</RETURNS>
const gchar *group_name, const gchar *key, gsize *length, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>rclib_settings_get_integer_list</NAME>
<RETURNS>gint  *</RETURNS>
const gchar *group_name, const gchar *key, gsize *length, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>rclib_settings_get_double_list</NAME>
<RETURNS>gdouble  *</RETURNS>
const gchar *group_name, const gchar *key, gsize *length, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>rclib_settings_set_string</NAME>
<RETURNS>void  </RETURNS>
const gchar *group_name, const gchar *key, const gchar *string 
</FUNCTION>
<FUNCTION>
<NAME>rclib_settings_set_boolean</NAME>
<RETURNS>void  </RETURNS>
const gchar *group_name, const gchar *key, gboolean value 
</FUNCTION>
<FUNCTION>
<NAME>rclib_settings_set_integer</NAME>
<RETURNS>void  </RETURNS>
const gchar *group_name, const gchar *key, gint value 
</FUNCTION>
<FUNCTION>
<NAME>rclib_settings_set_double</NAME>
<RETURNS>void  </RETURNS>
const gchar *group_name, const gchar *key, gdouble value 
</FUNCTION>
<FUNCTION>
<NAME>rclib_settings_set_string_list</NAME>
<RETURNS>void  </RETURNS>
const gchar *group_name, const gchar *key, const gchar * const list[], gsize length 
</FUNCTION>
<FUNCTION>
<NAME>rclib_settings_set_boolean_list</NAME>
<RETURNS>void  </RETURNS>
const gchar *group_name, const gchar *key, gboolean list[], gsize length 
</FUNCTION>
<FUNCTION>
<NAME>rclib_settings_set_integer_list</NAME>
<RETURNS>void  </RETURNS>
const gchar *group_name, const gchar *key, gint list[], gsize length 
</FUNCTION>
<FUNCTION>
<NAME>rclib_settings_set_double_list</NAME>
<RETURNS>void  </RETURNS>
const gchar *group_name, const gchar *key, gdouble list[], gsize length 
</FUNCTION>
<FUNCTION>
<NAME>rclib_settings_has_key</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *group_name, gchar *key, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>rclib_util_get_data_dir</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *name, const gchar *arg0 
</FUNCTION>
<FUNCTION>
<NAME>rclib_util_is_supported_media</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *file 
</FUNCTION>
<FUNCTION>
<NAME>rclib_util_is_supported_list</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *file 
</FUNCTION>
<FUNCTION>
<NAME>rclib_util_set_cover_search_dir</NAME>
<RETURNS>void  </RETURNS>
const gchar *dir 
</FUNCTION>
<FUNCTION>
<NAME>rclib_util_get_cover_search_dir</NAME>
<RETURNS>const gchar  *</RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_util_search_cover</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *uri, const gchar *title, const gchar *artist, const gchar *album 
</FUNCTION>
<FUNCTION>
<NAME>rclib_util_detect_encoding_by_locale</NAME>
<RETURNS>gchar  *</RETURNS>
 
</FUNCTION>
<ENUM>
<NAME>RCLibCueInputType</NAME>
typedef enum {
    RCLIB_CUE_INPUT_URI = 0,
    RCLIB_CUE_INPUT_PATH = 1,
    RCLIB_CUE_INPUT_EMBEDED = 2
}RCLibCueInputType;
</ENUM>
<STRUCT>
<NAME>RCLibCueTrack</NAME>
struct _RCLibCueTrack {
    guint index;
    gchar *title;
    gchar *performer;
    guint64 time0;
    guint64 time1;
};
</STRUCT>
<STRUCT>
<NAME>RCLibCueData</NAME>
struct _RCLibCueData {
    RCLibCueInputType type;
    gchar *file;
    gchar *performer;
    gchar *title;
    guint length;
    RCLibCueTrack *track;
};
</STRUCT>
<FUNCTION>
<NAME>rclib_cue_read_data</NAME>
<RETURNS>guint  </RETURNS>
const gchar *input, RCLibCueInputType type, RCLibCueData *data 
</FUNCTION>
<FUNCTION>
<NAME>rclib_cue_free</NAME>
<RETURNS>void  </RETURNS>
RCLibCueData *data 
</FUNCTION>
<FUNCTION>
<NAME>rclib_cue_get_track_num</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *path, gchar **cue_path, gint *track_num 
</FUNCTION>
<FUNCTION>
<NAME>rclib_cue_set_fallback_encoding</NAME>
<RETURNS>void  </RETURNS>
const gchar *encoding 
</FUNCTION>
<FUNCTION>
<NAME>rclib_cue_get_fallback_encoding</NAME>
<RETURNS>const gchar  *</RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>RCLIB_DBUS_TYPE</NAME>
#define RCLIB_DBUS_TYPE (rclib_dbus_get_type())
</MACRO>
<MACRO>
<NAME>RCLIB_DBUS</NAME>
#define RCLIB_DBUS(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), RCLIB_DBUS_TYPE, \
    RCLibDBus))
</MACRO>
<MACRO>
<NAME>RCLIB_DBUS_CLASS</NAME>
#define RCLIB_DBUS_CLASS(k) (G_TYPE_CHECK_CLASS_CAST((k), RCLIB_DBUS_TYPE, \
    RCLibDBusClass))
</MACRO>
<MACRO>
<NAME>RCLIB_IS_DBUS</NAME>
#define RCLIB_IS_DBUS(o) (G_TYPE_CHECK_INSTANCE_TYPE((o), RCLIB_DBUS_TYPE))
</MACRO>
<MACRO>
<NAME>RCLIB_IS_DBUS_CLASS</NAME>
#define RCLIB_IS_DBUS_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE((k), RCLIB_DBUS_TYPE))
</MACRO>
<MACRO>
<NAME>RCLIB_DBUS_GET_CLASS</NAME>
#define RCLIB_DBUS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), \
    RCLIB_DBUS_TYPE, RCLibDBusClass))
</MACRO>
<STRUCT>
<NAME>RCLibDBus</NAME>
struct _RCLibDBus {
    /*< private >*/
    GObject parent;
};
</STRUCT>
<STRUCT>
<NAME>RCLibDBusClass</NAME>
struct _RCLibDBusClass {
    /*< private >*/
    GObjectClass parent_class;
    void (*quit)(RCLibDBus *dbus);
    void (*raise)(RCLibDBus *dbus);
    void (*seeked)(RCLibDBus *bus, gint64 offset);
};
</STRUCT>
<FUNCTION>
<NAME>rclib_dbus_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_dbus_init</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *app_name, const gchar *first_property_name, ... 
</FUNCTION>
<FUNCTION>
<NAME>rclib_dbus_exit</NAME>
<RETURNS>void  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_dbus_get_instance</NAME>
<RETURNS>GObject  *</RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_dbus_signal_connect</NAME>
<RETURNS>gulong  </RETURNS>
const gchar *name, GCallback callback, gpointer data 
</FUNCTION>
<FUNCTION>
<NAME>rclib_dbus_signal_disconnect</NAME>
<RETURNS>void  </RETURNS>
gulong handler_id 
</FUNCTION>
<MACRO>
<NAME>RCLIB_DB_TYPE</NAME>
#define RCLIB_DB_TYPE (rclib_db_get_type())
</MACRO>
<MACRO>
<NAME>RCLIB_DB</NAME>
#define RCLIB_DB(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), RCLIB_DB_TYPE, \
    RCLibDb))
</MACRO>
<MACRO>
<NAME>RCLIB_DB_CLASS</NAME>
#define RCLIB_DB_CLASS(k) (G_TYPE_CHECK_CLASS_CAST((k), RCLIB_DB_TYPE, \
    RCLibDbClass))
</MACRO>
<MACRO>
<NAME>RCLIB_IS_DB</NAME>
#define RCLIB_IS_DB(o) (G_TYPE_CHECK_INSTANCE_TYPE((o), RCLIB_DB_TYPE))
</MACRO>
<MACRO>
<NAME>RCLIB_IS_DB_CLASS</NAME>
#define RCLIB_IS_DB_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE((k), RCLIB_DB_TYPE))
</MACRO>
<MACRO>
<NAME>RCLIB_DB_GET_CLASS</NAME>
#define RCLIB_DB_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), \
    RCLIB_DB_TYPE, RCLibDbClass))
</MACRO>
<ENUM>
<NAME>RCLibDbCatalogType</NAME>
typedef enum {
    RCLIB_DB_CATALOG_TYPE_PLAYLIST = 1
}RCLibDbCatalogType;
</ENUM>
<ENUM>
<NAME>RCLibDbPlaylistType</NAME>
typedef enum {
    RCLIB_DB_PLAYLIST_TYPE_MISSING = 0,
    RCLIB_DB_PLAYLIST_TYPE_MUSIC = 1,
    RCLIB_DB_PLAYLIST_TYPE_CUE = 2
}RCLibDbPlaylistType;
</ENUM>
<STRUCT>
<NAME>RCLibDbCatalogData</NAME>
struct _RCLibDbCatalogData {
    /*< private >*/
    gint ref_count;
    
    /*< public >*/
    GSequence *playlist;
    gchar *name;
    RCLibDbCatalogType type;
    gpointer store;
};
</STRUCT>
<STRUCT>
<NAME>RCLibDbPlaylistData</NAME>
struct _RCLibDbPlaylistData {
    /*< private >*/
    gint ref_count;

    /*< public >*/
    GSequenceIter *catalog;
    RCLibDbPlaylistType type;
    gchar *uri;
    gchar *title;
    gchar *artist;
    gchar *album;
    gchar *ftype;
    gint64 length;
    gint tracknum;
    gint year;
    guint rating;
    gchar *lyricfile;
    gchar *lyricsecfile;
    gchar *albumfile;
};
</STRUCT>
<STRUCT>
<NAME>RCLibDb</NAME>
struct _RCLibDb {
    /*< private >*/
    GObject parent;
};
</STRUCT>
<STRUCT>
<NAME>RCLibDbClass</NAME>
struct _RCLibDbClass {
    /*< private >*/
    GObjectClass parent_class;
    void (*catalog_added)(RCLibDb *db, GSequenceIter *iter);
    void (*catalog_changed)(RCLibDb *db, GSequenceIter *iter);
    void (*catalog_delete)(RCLibDb *db, GSequenceIter *iter);
    void (*catalog_reordered)(RCLibDb *db, gint *new_order);
    void (*playlist_added)(RCLibDb *db, GSequenceIter *iter);
    void (*playlist_changed)(RCLibDb *db, GSequenceIter *iter);
    void (*playlist_delete)(RCLibDb *db, GSequenceIter *iter);
    void (*playlist_reordered)(RCLibDb *db, GSequenceIter *iter,
        gint *new_order);
    void (*import_updated)(RCLibDb *db, gint remaining);
    void (*refresh_updated)(RCLibDb *db, gint remaining);
};
</STRUCT>
<FUNCTION>
<NAME>rclib_db_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_init</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *file 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_exit</NAME>
<RETURNS>void  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_get_instance</NAME>
<RETURNS>GObject  *</RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_signal_connect</NAME>
<RETURNS>gulong  </RETURNS>
const gchar *name, GCallback callback, gpointer data 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_signal_disconnect</NAME>
<RETURNS>void  </RETURNS>
gulong handler_id 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_catalog_data_new</NAME>
<RETURNS>RCLibDbCatalogData  *</RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_catalog_data_ref</NAME>
<RETURNS>RCLibDbCatalogData  *</RETURNS>
RCLibDbCatalogData *data 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_catalog_data_unref</NAME>
<RETURNS>void  </RETURNS>
RCLibDbCatalogData *data 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_catalog_data_free</NAME>
<RETURNS>void  </RETURNS>
RCLibDbCatalogData *data 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_playlist_data_new</NAME>
<RETURNS>RCLibDbPlaylistData  *</RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_playlist_data_ref</NAME>
<RETURNS>RCLibDbPlaylistData  *</RETURNS>
RCLibDbPlaylistData *data 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_playlist_data_unref</NAME>
<RETURNS>void  </RETURNS>
RCLibDbPlaylistData *data 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_playlist_data_free</NAME>
<RETURNS>void  </RETURNS>
RCLibDbPlaylistData *data 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_catalog_add</NAME>
<RETURNS>GSequenceIter  *</RETURNS>
const gchar *name, GSequenceIter *iter, gint type 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_get_catalog</NAME>
<RETURNS>GSequence  *</RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_catalog_delete</NAME>
<RETURNS>void  </RETURNS>
GSequenceIter *iter 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_catalog_set_name</NAME>
<RETURNS>void  </RETURNS>
GSequenceIter *iter, const gchar *name 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_catalog_set_type</NAME>
<RETURNS>void  </RETURNS>
GSequenceIter *iter, RCLibDbCatalogType type 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_catalog_reorder</NAME>
<RETURNS>void  </RETURNS>
gint *new_order 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_playlist_add_music</NAME>
<RETURNS>void  </RETURNS>
GSequenceIter *iter, GSequenceIter *insert_iter, const gchar *uri 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_playlist_add_music_and_play</NAME>
<RETURNS>void  </RETURNS>
GSequenceIter *iter, GSequenceIter *insert_iter, const gchar *uri 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_playlist_delete</NAME>
<RETURNS>void  </RETURNS>
GSequenceIter *iter 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_playlist_update_metadata</NAME>
<RETURNS>void  </RETURNS>
GSequenceIter *iter, const RCLibDbPlaylistData *data 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_playlist_update_length</NAME>
<RETURNS>void  </RETURNS>
GSequenceIter *iter, gint64 length 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_playlist_set_type</NAME>
<RETURNS>void  </RETURNS>
GSequenceIter *iter, RCLibDbPlaylistType type 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_playlist_set_rating</NAME>
<RETURNS>void  </RETURNS>
GSequenceIter *iter, gint rating 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_playlist_set_lyric_bind</NAME>
<RETURNS>void  </RETURNS>
GSequenceIter *iter, const gchar *filename 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_playlist_set_lyric_secondary_bind</NAME>
<RETURNS>void  </RETURNS>
GSequenceIter *iter, const gchar *filename 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_playlist_set_album_bind</NAME>
<RETURNS>void  </RETURNS>
GSequenceIter *iter, const gchar *filename 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_playlist_get_lyric_bind</NAME>
<RETURNS>const gchar  *</RETURNS>
GSequenceIter *iter 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_playlist_get_lyric_secondary_bind</NAME>
<RETURNS>const gchar  *</RETURNS>
GSequenceIter *iter 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_playlist_get_album_bind</NAME>
<RETURNS>const gchar  *</RETURNS>
GSequenceIter *iter 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_playlist_reorder</NAME>
<RETURNS>void  </RETURNS>
GSequenceIter *iter, gint *new_order 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_playlist_move_to_another_catalog</NAME>
<RETURNS>void  </RETURNS>
GSequenceIter **iters, guint num, GSequenceIter *catalog_iter 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_playlist_add_m3u_file</NAME>
<RETURNS>void  </RETURNS>
GSequenceIter *iter, GSequenceIter *insert_iter, const gchar *filename 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_playlist_add_directory</NAME>
<RETURNS>void  </RETURNS>
GSequenceIter *iter, GSequenceIter *insert_iter, const gchar *dir 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_playlist_export_m3u_file</NAME>
<RETURNS>gboolean  </RETURNS>
GSequenceIter *iter, const gchar *sfilename 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_playlist_export_all_m3u_files</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *dir 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_playlist_refresh</NAME>
<RETURNS>void  </RETURNS>
GSequenceIter *iter 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_playlist_import_cancel</NAME>
<RETURNS>void  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_playlist_refresh_cancel</NAME>
<RETURNS>void  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_playlist_import_queue_get_length</NAME>
<RETURNS>gint  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_playlist_refresh_queue_get_length</NAME>
<RETURNS>gint  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>rclib_db_playlist_sync</NAME>
<RETURNS>gboolean  </RETURNS>
 
</FUNCTION>
<VARIABLE>
<NAME>rclib_major_version</NAME>
extern const guint rclib_major_version;
</VARIABLE>
<VARIABLE>
<NAME>rclib_minor_version</NAME>
extern const guint rclib_minor_version;
</VARIABLE>
<VARIABLE>
<NAME>rclib_micro_version</NAME>
extern const guint rclib_micro_version;
</VARIABLE>
<VARIABLE>
<NAME>rclib_build_date</NAME>
extern const gchar *rclib_build_date;
</VARIABLE>
<VARIABLE>
<NAME>rclib_build_time</NAME>
extern const gchar *rclib_build_time;
</VARIABLE>
<FUNCTION>
<NAME>rclib_init</NAME>
<RETURNS>gboolean  </RETURNS>
gint *argc, gchar **argv[], const gchar *dir, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>rclib_exit</NAME>
<RETURNS>void  </RETURNS>
 
</FUNCTION>
